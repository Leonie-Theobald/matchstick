use super::Puzzle;
use super::Riddle;
use crate::equation::EquationPattern;

/// Searches for specific [`Puzzle`]s where [`Riddle`] (and solution) fulfill given general [`EquationPattern`]
pub struct PuzzleGenerator {
    riddle_equation_pattern: EquationPattern,
    number_matchstick_movements: usize,
    solution_equation_pattern: Option<EquationPattern>,
}

impl PuzzleGenerator {
    /// The [`EquationPattern`] describes riddle equation and the [`usize`] tells
    /// how many matchsticks must be moved to solve the [`Puzzle`] generated by [`PuzzleGenerator`]
    /// ```
    /// # use matchstick::equation::EquationPattern;
    /// # use matchstick::puzzle::puzzle_generator::PuzzleGenerator;
    /// # use matchstick::symbol::SymbolFilter;
    /// let equation_pattern = EquationPattern::new_from_symbol_filters(vec![SymbolFilter::IsNumber]);
    /// let puzzle_generator = PuzzleGenerator::new(equation_pattern, 2);
    /// // solution pattern is set to `None` by default
    /// assert_eq!(&None, puzzle_generator.get_solution_equation_pattern());
    /// ```
    pub fn new(
        riddle_equation_pattern: EquationPattern,
        number_matchstick_movements: usize,
    ) -> Self {
        PuzzleGenerator {
            riddle_equation_pattern,
            number_matchstick_movements,
            solution_equation_pattern: None,
        }
    }

    /// Find all [`Puzzle`]s where the riddle matches the given pattern and has only n solutions \
    /// If the solution pattern is given, this only returns [`Puzzle`]s where the solution matches
    pub fn derive_puzzles_with_n_solutions(&self, number_solutions: usize) -> Vec<Puzzle> {
        let mut puzzles = Vec::new();

        'outer: for riddle_equation in self.riddle_equation_pattern.derive_concrete_equations() {
            // for each starting equation a new puzzle is set up to be solved then
            let mut puzzle = Puzzle::new_from_riddle(Riddle::new(
                riddle_equation,
                self.number_matchstick_movements,
            ));

            if number_solutions != puzzle.search_and_set_solution() {
                continue; // the riddle_equation has not requested number of solutions
            }

            // if solution pattern is set, all solution equations must fulfill it
            // in order for the riddle equation to be valid
            if let Some(solution_equation_pattern) = &self.solution_equation_pattern {
                let solution = match puzzle.wrapped_solution.get_inner_reference() {
                    Ok(solution_equations) => solution_equations,
                    Err(()) => continue 'outer, // go to next riddle equation,
                };
                for solution_equation in solution.get_solution_equations() {
                    if !solution_equation.fulfills_abstract_equation(solution_equation_pattern) {
                        continue 'outer; // go to next riddle equation
                    }
                }
            }

            puzzles.push(puzzle);
        }

        puzzles
    }

    /// Setter function for number of matchstick movements
    pub fn set_riddle_equation_pattern(&mut self, riddle_equation_pattern: EquationPattern) {
        self.riddle_equation_pattern = riddle_equation_pattern;
    }

    /// Setter function for number of matchstick movements
    pub fn set_number_matchstick_movements(&mut self, number_matchstick_movements: usize) {
        self.number_matchstick_movements = number_matchstick_movements;
    }

    /// Set what [`EquationPattern`] the solution equations must fulfill. Only then the specific [`Riddle`] and
    /// solution form a valid [`Puzzle`] generated by [`PuzzleGenerator`]
    /// ```
    /// # use matchstick::equation::EquationPattern;
    /// # use matchstick::puzzle::puzzle_generator::PuzzleGenerator;
    /// # use matchstick::symbol::SymbolFilter;
    /// # let riddle_equation_pattern = EquationPattern::new_from_symbol_filters(vec![SymbolFilter::IsNumber]);
    /// let solution_equation_pattern =
    ///     EquationPattern::new_from_symbol_filters(vec![SymbolFilter::IsNumber]);
    /// let mut puzzle_generator = PuzzleGenerator::new(riddle_equation_pattern, 1);
    /// puzzle_generator.set_solution_equation_pattern(solution_equation_pattern);
    /// assert!(matches!(
    ///     puzzle_generator.get_solution_equation_pattern(),
    ///     &Some(EquationPattern { .. })
    /// ));
    /// ```
    pub fn set_solution_equation_pattern(&mut self, solution_equation_pattern: EquationPattern) {
        self.solution_equation_pattern = Some(solution_equation_pattern);
    }

    /// Getter function for riddle [`EquationPattern`]
    pub fn get_riddle_equation_pattern(&self) -> &EquationPattern {
        &self.riddle_equation_pattern
    }

    /// Getter function for number of matchstick movements
    pub fn get_number_matchstick_movements(&self) -> &usize {
        &self.number_matchstick_movements
    }

    /// Getter function for solution [`EquationPattern`]
    pub fn get_solution_equation_pattern(&self) -> &Option<EquationPattern> {
        &self.solution_equation_pattern
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::equation::Equation;
    use crate::puzzle::SolutionWrapper;
    use crate::symbol::{Symbol, SymbolFilter};

    #[test]
    fn generate_puzzle_with_no_matchstick_movement() {
        let riddle_pattern = EquationPattern::new_from_symbol_filters(vec![
            SymbolFilter::IsNumber,
            SymbolFilter::List(vec![Symbol::Equal]),
            SymbolFilter::List(vec![Symbol::Three]),
        ]);

        let puzzle_generator = PuzzleGenerator {
            riddle_equation_pattern: riddle_pattern,
            solution_equation_pattern: None,
            number_matchstick_movements: 0,
        };

        let expected_puzzles = vec![Puzzle {
            riddle: Riddle::new(
                Equation::new_from_symbols(vec![Symbol::Three, Symbol::Equal, Symbol::Three]),
                0,
            ),
            wrapped_solution: SolutionWrapper::new_programmatically_set_solution(vec![
                Equation::new_from_symbols(vec![Symbol::Three, Symbol::Equal, Symbol::Three]),
            ]),
        }];

        assert_eq!(
            puzzle_generator.derive_puzzles_with_n_solutions(1),
            expected_puzzles
        );
    }

    #[test]
    fn no_matching_puzzle() {
        let riddle_pattern = EquationPattern::new_from_symbol_filters(vec![
            SymbolFilter::List(vec![Symbol::Nine]),
            SymbolFilter::List(vec![Symbol::Equal]),
            SymbolFilter::List(vec![Symbol::Three]),
        ]);

        let puzzle_generator = PuzzleGenerator {
            riddle_equation_pattern: riddle_pattern,
            solution_equation_pattern: None,
            number_matchstick_movements: 1,
        };

        assert_eq!(
            puzzle_generator.derive_puzzles_with_n_solutions(1),
            Vec::new()
        );
    }

    #[test]
    fn change_number_matchstick_movements() {
        let equation_pattern = EquationPattern::new_from_symbol_filters(vec![]);
        let mut puzzle_generator = PuzzleGenerator {
            riddle_equation_pattern: equation_pattern,
            number_matchstick_movements: 3,
            solution_equation_pattern: None,
        };

        assert_eq!(3, *puzzle_generator.get_number_matchstick_movements());

        puzzle_generator.set_number_matchstick_movements(1);
        assert_eq!(1, *puzzle_generator.get_number_matchstick_movements());
    }

    #[test]
    fn change_riddle_equation_pattern() {
        let equation_pattern = EquationPattern::new_from_symbol_filters(vec![]);
        let mut puzzle_generator = PuzzleGenerator {
            riddle_equation_pattern: equation_pattern.clone(),
            number_matchstick_movements: 3,
            solution_equation_pattern: None,
        };

        assert_eq!(
            equation_pattern,
            *puzzle_generator.get_riddle_equation_pattern()
        );

        let changed_equation_pattern =
            EquationPattern::new_from_symbol_filters(vec![SymbolFilter::IsAny]);

        puzzle_generator.set_riddle_equation_pattern(changed_equation_pattern.clone());
        assert_eq!(
            changed_equation_pattern,
            *puzzle_generator.get_riddle_equation_pattern()
        );
    }
}
